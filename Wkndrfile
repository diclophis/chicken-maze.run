#

PRIMARY  = 0x000000FF

class MazeGame
  def test_aabb(min_a, max_a, min_b, max_b)
    d1x = -min_b[0] - -max_a[0]
    d1y = -min_b[1] - -max_a[1]
    d2x = -min_a[0] - -max_b[0]
    d2y = -min_a[1] - -max_b[1]

    if (d1x > 0.0 || d1y > 0.0)
      return false
    elsif (d2x > 0.0 || d2y > 0.0)
      return false
    else
      a = (d2x - d1x).abs
      b = (d2y - d1y).abs
      if a > b
        if d2x < d1x
          b = 0.0
        else
          b = 0.0
        end

        return [:y, b]
      else
        if d2y < d1y
          a = 0.0
        else
          a = 0.0
        end

        return [:x, a]
      end
    end
  end

  def level
    @maze_level
  end

  def initialize(maze_level, cube, shapes, shape_translate_table)
    @shapes = shapes
    @shape_translate_table = shape_translate_table
    @cube = cube

    @cpx = -1
    @cpy = -1

    @at_exit_time = 0.0

    @enforce_bounds = true

    @floor_position = 0.125

    @player_position = [0.0,@floor_position-0.025,0.0]
    @player_velocity = [0.0, 0.0, 0.0]
    @camera_position = [0.0, 0.0, 0.0]
    @camera_target = [0.0, 0.0, 0.0]

    @top_left_min = [1.1, 1.1]
    @top_left_max = [0.1, 0.1]
    @top_right_min = [-0.1, 1.1]
    @top_right_max = [-1.1, 0.1]
    @bottom_left_min = [1.1, -0.1]
    @bottom_left_max = [0.1, -1.1]
    @bottom_right_min = [-0.1, -0.1]
    @bottom_right_max = [-1.1, -1.1]

    @no_left_min = [1.1, 0.1]
    @no_left_max = [0.1, -0.1]
    @no_right_min = [-0.1, 0.1]
    @no_right_max = [-1.1, -0.1]
    @no_up_min = [0.1, 1.1]
    @no_up_max = [-0.1, 0.1]
    @no_down_min = [0.1, -0.1]
    @no_down_max = [-0.1, -1.1]

    # left to right
    @lne_x1 = 0.0
    @lne_y1 = -1.0

    @lne_x2 = 0.0
    @lne_y2 = 1.0

    # up to down
    @lin_x1 = -1.0
    @lin_y1 = 0.0

    @lin_x2 = 1.0
    @lin_y2 = 0.0

    @fovy = 60.0
    @maze_draw_distance = 4

    @cool_down = [99, 99]

    @time_since_last_hop = 99
    @time_since_last_input = [99, 99]

    dice_roll_draw_buffer

    @maze_level = maze_level
    @players = {}

    @ticks = 0
  end

  def load_maze!(l, s, e, b)
    if @maze_level == l
      @maze_s = s
      @maze_exit = e
      @maze = b
    end
  end

  def dice_roll_draw_buffer
    @draw_buffer = []
    (((@maze_draw_distance + 1) * 2) * ((@maze_draw_distance + 1) * 2)).times {
      @draw_buffer << (rand * 15.0).to_i
    }
  end

  def draw(gl)
    return unless @maze && @px && @py
    #return unless @ticks > 3

    gl.lookat(1, *@camera_position, *@camera_target, @fovy)

    ((@px-@maze_draw_distance)..(@px+@maze_draw_distance)).each do |x|
      ((@py-@maze_draw_distance)..(@py+@maze_draw_distance)).each do |y|
        if x>=0 && x<@maze_s && y>=0 && y<@maze_s
          cell = @maze[x][y]
          unless cell == 0
            primary = (cell & PRIMARY)

            if shape = @shapes[primary]
              shape.deltap(x, 0, y)
              shape.draw(false)
            end
          end
        end
      end
    end

    @cube.deltar(0.0, 1.0, 0.0, (Math.atan2(@player_velocity[0], @player_velocity[2]) * (180.0/3.14)) + 0.0)
    @cube.deltap(*@player_position)
    @cube.draw(false)
    
    @players.each { |key, rpv|
      player_position, player_velocity = *rpv

      player_position[0] += (player_velocity[0] * delta_time * 1.0)
      player_position[2] += (player_velocity[2] * delta_time * 1.0)

      @cube.deltar(0.0, 1.0, 0.0, (Math.atan2(player_velocity[0], player_velocity[2]) * (180.0/3.14)) + 0.0)
      @cube.deltap(*player_position)
      @cube.draw(false)
    }
  end

  def update(gl, global_time, delta_time)
    return unless @maze

    px = py = nx = ny = 0
    got_lr = got_ud = false
    player_at_shape = nil
    at_left_right_limit = nil
    at_up_down_limit = nil
    player_min = player_max = [0, 0]
    allow_up = false
    allow_down = false
    allow_left = false
    allow_right = false
    bounced = false
    no_bounce_reset = 0

    allow_up = false
    allow_down = false
    allow_left = false
    allow_right = false

    arrow_keys = gl.keyspressed(KEY_W, KEY_A, KEY_S, KEY_D, KEY_UP, KEY_DOWN)
    speed = 0.0345
    friction = 5.67
    max_v = 1.0
    rfx = 1.0
    rfy = 1.0
    hop_timeout = 0.25
    did_hop = false

    if @time_since_last_hop > hop_timeout
      @time_since_last_hop = 0
      dice_roll_draw_buffer
      gl.emit({"position" => {$HEX => [@maze_level, @player_position, @player_velocity]}})
    end 

    this_direction = 2.33

    intended_forces = [0, 0]

    arrow_keys.each do |arrow_key|
      case arrow_key
        when KEY_W
          got_ud = true
          intended_forces[1] = this_direction
        when KEY_S
          got_ud = true
          intended_forces[1] = -this_direction
        when KEY_A
          got_lr = true
          intended_forces[0] = this_direction
        when KEY_D
          got_lr = true
          intended_forces[0] = -this_direction
      end
    end

    if @player_velocity[2] > max_v
      @player_velocity[2] = max_v
    end

    if @player_velocity[0] > max_v
      @player_velocity[0] = max_v
    end

    if @player_velocity[0] < -max_v
      @player_velocity[0] = -max_v
    end

    if @player_velocity[2] < -max_v
      @player_velocity[2] = -max_v
    end


    nx = @player_position[0] + (@player_velocity[0] * delta_time)
    ny = @player_position[2] + (@player_velocity[2] * delta_time)

    px = ((nx - 0).round)
    py = ((ny - 0).round)

    if px >= 0 && px < @maze_s && py >= 0 && py < @maze_s
      player_at_shape_cell = @maze[px.to_i][py.to_i]
      player_at_shape = @shape_translate_table[(player_at_shape_cell & PRIMARY)]
    end

    case player_at_shape
      when 0
        allow_up = allow_down = allow_left = allow_right = true
      when 1
        allow_down = allow_left = allow_right = true
      when 2
        allow_up = allow_left = allow_right = true
      when 3
        allow_up = allow_down = allow_left = true
      when 4
        allow_up = allow_down = allow_right = true
      when 5
        allow_right = true
      when 6
        allow_left = true
      when 7
        allow_up = true
      when 8
        allow_down = true
      when 9
        allow_down = allow_up = true
        #TODO
        #includes left right crossing bits
      when 10
        allow_left = allow_right = true
      when 11
        allow_up = allow_left = true
      when 12
        allow_down = allow_left = true
      when 13
        allow_down = allow_right = true
      when 14
        allow_right = true
        allow_up = true
    end

    at_left_right_limit = ((nx - px))
    at_up_down_limit = ((ny - py))

    player_min = [at_left_right_limit + 0.05, at_up_down_limit + 0.05]
    player_max = [at_left_right_limit - 0.05, at_up_down_limit - 0.05]

    bounced = false
    correction = 0

    if ab = test_aabb(@top_left_min, @top_left_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if ab = test_aabb(@bottom_left_min, @bottom_left_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if ab = test_aabb(@bottom_right_min, @bottom_right_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if ab = test_aabb(@top_right_min, @top_right_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if !allow_left && ab = test_aabb(@no_left_min, @no_left_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if !allow_right && ab = test_aabb(@no_right_min, @no_right_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if !allow_up && ab = test_aabb(@no_up_min, @no_up_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if !allow_down && ab = test_aabb(@no_down_min, @no_down_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if @maze_exit == [px, py]
      @at_exit_time += delta_time

      if @at_exit_time > 0.0
        return :level_up
      end
    elsif [-1, 0] == [px, py]
      @at_exit_time += delta_time

      if @at_exit_time > 0.0
        return :level_down
      end
    else
      @at_exit_time = 0.0
    end

    skip_camera_update = false

    if !player_at_shape 
      @player_velocity[0] = -@player_velocity[0]
      @player_velocity[2] = -@player_velocity[2]
      skip_camera_update = true
    else
      if bounced
        line = nil

        if bounced == :y
          @cool_down[0] = 0.0
          line = [@lne_x1, @lne_y1, @lne_x2, @lne_y2]
        end

        if bounced == :x
          @cool_down[1] = 0.0
          line = [@lin_x1, @lin_y1, @lin_x2, @lin_y2]
        end

        line_x1, line_y1, line_x2, line_y2 = line

        normalY = line_x2 - line_x1
        normalX = line_y1 - line_y2
        normalLength = Math.sqrt(normalX * normalX + normalY * normalY)
        normalX = normalX / normalLength
        normalY = normalY / normalLength
        rayTipX = @player_velocity[0]
        rayTipY = @player_velocity[2]
        rayX = rayTipX
        rayY = rayTipY 
        dotProduct = (rayX * normalX) + (rayY * normalY)
        dotNormalX = dotProduct * normalX
        dotNormalY = dotProduct * normalY
        reflectedRayTipX = rayTipX - (dotNormalX * 2)
        reflectedRayTipY = rayTipY - (dotNormalY * 2)
        @player_velocity[0] = (reflectedRayTipX * rfx)
        @player_velocity[2] = (reflectedRayTipY * rfy)
      else
        @cool_down[0] += delta_time
        @cool_down[1] += delta_time

        @player_position[0] = nx
        @player_position[2] = ny
      end
    end

    @time_since_last_hop += delta_time

    follow_speed = 0.20

    if @cool_down[0] < 0.33 
      follow_speed *= (1.0 - @cool_down[0])
    end

    if @cool_down[1] < 0.33
      follow_speed *= (1.0 - @cool_down[1])
    end

    if !got_lr || bounced
      @player_velocity[0] *= 1.0 - (friction * delta_time)
      intended_forces[0] = 0.0
    end

    if !got_ud || bounced
      @player_velocity[2] *= 1.0 - (friction * delta_time)
      intended_forces[1] = 0.0
    end

    @player_velocity[0] += intended_forces[0] * delta_time
    @player_velocity[2] += intended_forces[1] * delta_time

    @camera_position[1] = 1.75

    @camera_target[0] -= (@camera_target[0] - (@player_position[0] + (follow_speed * @player_velocity[0]))) * (delta_time * 1.0)
    @camera_target[2] -= (@camera_target[2] - (@player_position[2] + (follow_speed * @player_velocity[2]))) * (delta_time * 1.0)

    @camera_position[0] += (@camera_target[0] - @camera_position[0]) * delta_time  * follow_speed * 10.0
    @camera_position[2] += (((@camera_target[2] - 1.25) - @camera_position[2]) * delta_time  * follow_speed * 10.0)

    if px != @cpx
      @cpx = px
    end

    if py != @cpy
      @cpy = py
    end

    @px = px
    @py = py

    @ticks += 1

    :keep_running
  end

  def track_other_players!(msg)
    player_updated = msg.keys
    player_updated.each { |player|
      maze_level, player_position, player_velocity = msg[player]

      if @maze_level == maze_level
        @players.merge!({player => [player_position, player_velocity]})
      end
    }
  end
end

Wkndr.nonce {
  Wkndr.client_side { |gl|
    gl.open_default_view!

    chicken_file = "resources/chicken.glb"
    cube = Model.new(chicken_file, "", 0.125)

    shapes = {}
    shape_translate_table = {}

    16.times { |i|
      ii = begin
        case i
          when 1
            8
          when 2
            7
          when 3
            9
          when 4
            6
          when 5
            12
          when 6
            11
          when 7
            3
          when 8
            5
          when 9
            13
          when 10
            14
          when 11
            4
          when 12
            10
          when 13
            1
          when 14
            2
          when 15
            0
        else
          nil
        end
      end

      if ii
        shape_translate_table[i] = ii
        shape_file = "resources/shape-#{ii}.glb"
        shapes[i] = Model.new(shape_file, "", 1.0)
      end
    }

    @start_game_proc = Proc.new { |maze_level|
      if maze_level < 1
        maze_level = 1
      end

      @maze_game = MazeGame.new(maze_level, cube, shapes, shape_translate_table)
      gl.emit({"mkmaze" => maze_level})
    }

    @start_game_proc.call(1)
  }
}

Wkndr.server_side { |gl, server|
  server.wsb("/") do |cn, phr|
  end
}

Wkndr.client_side { |gl|
  gl.event { |channel, msg|
    case channel
      when "position"
        @maze_game.track_other_players!(msg)

      when "maze"
        @maze_game.load_maze!(*msg)
    end
  }

  gl.update { |global_time, delta_time|
    case @maze_game.update(gl, global_time, delta_time)
      when :level_up
        @start_game_proc.call(@maze_game.level + 1)

      when :level_down
        @start_game_proc.call(@maze_game.level - 1)

    end

    gl.drawmode {
      gl.threed {
        @maze_game.draw(gl)
      }
    }
  }
}
