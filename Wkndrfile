# vi:syntax=ruby

class GameCamera
  def initialize
    @camera_target = [0, 0, 0]
    @camera_position = [-0.0, 0, -3.0]
    @camera_position[1] = 2.0
  end

  def update(gl, global_time, delta_time, player_position)
    follow_speed = 0.75
    follow_look_speed = 5.0

    @camera_target[0] += (player_position[0] - @camera_target[0]) * (1.0 * (player_position[0] - @camera_target[0]).abs) * follow_look_speed * delta_time
    @camera_target[2] += (player_position[2] - @camera_target[2]) * (1.0 * (player_position[2] - @camera_target[2]).abs) * follow_look_speed * delta_time

    @camera_position[0] += ((@camera_target[0] - @camera_position[0]) * follow_speed * delta_time)
    @camera_position[2] += (((@camera_target[2] - 2.25) - @camera_position[2]) * follow_speed * delta_time)
  end

  def lookat(gl, player_position)
    gl.lookat(1, *@camera_position, *@camera_target, 40.0)
  end
end

class GameEngine
  PRIMARY  = 0x000000FF

  def initialize(maze_level, cube, shapes, direction)
    if maze_level < 1
      maze_level = 1
    end

    @shapes = shapes
    @cube = cube

    @px = 0
    @py = 0

    @cpx = -1
    @cpy = -1

    @at_exit_time = 0.0

    @enforce_bounds = true

    @floor_position = 0.125

    @player_position = [0.0,@floor_position-0.025,0.0]

    if direction == :level_down
      #if maze_level == 1
        @start_at_exit = true
      #end
    elsif direction == :level_up
      @player_position = [-0.45,@floor_position-0.025,0.0]
    end

    @player_velocity = [0.0, 0.0, 0.0]

    @top_left_min = [1.1, 1.1]
    @top_left_max = [0.1, 0.1]
    @top_right_min = [-0.1, 1.1]
    @top_right_max = [-1.1, 0.1]
    @bottom_left_min = [1.1, -0.1]
    @bottom_left_max = [0.1, -1.1]
    @bottom_right_min = [-0.1, -0.1]
    @bottom_right_max = [-1.1, -1.1]

    @no_left_min = [1.1, 0.1]
    @no_left_max = [0.1, -0.1]
    @no_right_min = [-0.1, 0.1]
    @no_right_max = [-1.1, -0.1]
    @no_up_min = [0.1, 1.1]
    @no_up_max = [-0.1, 0.1]
    @no_down_min = [0.1, -0.1]
    @no_down_max = [-0.1, -1.1]

    # left to right
    @lne_x1 = 0.0
    @lne_y1 = -1.0

    @lne_x2 = 0.0
    @lne_y2 = 1.0

    # up to down
    @lin_x1 = -1.0
    @lin_y1 = 0.0

    @lin_x2 = 1.0
    @lin_y2 = 0.0

    @fovy = 40.0
    @maze_draw_distance = 3

    @cool_down = [99, 99]

    @time_since_last_hop = 99
    @time_since_last_input = [99, 99]

    @maze_level = maze_level
    @players = {}

    @ticks = 0
  end

  def player_position
    @player_position
  end

  def self.process_time(gl, global_time, delta_time)
    @camera.update(gl, global_time, delta_time, @game.player_position)

    case @game.update(gl, global_time, delta_time)
      when :level_up
        @start_game_proc.call(@game.level + 1, :level_up)
      when :level_down
        @start_game_proc.call(@game.level - 1, :level_down)
    end
  end

  def self.draw_threed(gl)
    @camera.lookat(gl, @game.player_position)

    @game.draw_threed(gl)
  end

  def self.draw_twod(gl)
    @game.draw_twod(gl)
  end

  def self.start(gl, cube, shapes, starting_level = 1, direction = :level_up)
    @start_game_proc ||= Proc.new { |maze_level, direction_inner|
      @camera = GameCamera.new
      @game = self.new(maze_level, cube, shapes, direction_inner)
      gl.emit({"mkmaze" => @game.level})
    }
    @start_game_proc.call(starting_level, direction)
  end

  def self.event(channel, msg)
    if @game
      case channel
        when "position"
          @game.track_other_players!(msg)
        when "maze"
          @game.load_maze!(*msg)
      end
    end
  end

  def level
    @maze_level
  end

  def load_maze!(l, s, e, b)
    if @maze_level == l
      @maze_s = s
      @maze_exit = e
      @maze = b

      @player_position = [@maze_exit[0] - 0.75,@floor_position-0.025, @maze_exit[1]] if @start_at_exit
    end
  end

  def update(gl, global_time, delta_time)
    @last_delta_time = delta_time
    @last_global_time = global_time
    @ticks += 1

    return unless @maze

    px = py = nx = ny = 0
    got_lr = got_ud = false
    player_at_shape = nil
    at_left_right_limit = nil
    at_up_down_limit = nil
    player_min = player_max = [0, 0]
    allow_up = false
    allow_down = false
    allow_left = false
    allow_right = false
    bounced = false
    no_bounce_reset = 0

    allow_up = false
    allow_down = false
    allow_left = false
    allow_right = false

    arrow_keys = gl.keyspressed(KEY_W, KEY_A, KEY_S, KEY_D, KEY_UP, KEY_DOWN)
    speed = 0.1
    friction = speed * 1.1
    max_v = 1.0
    rfx = 1.01
    rfy = 1.01
    hop_timeout = 1.0

    this_direction = speed

    intended_forces = [0, 0]

    arrow_keys.each do |arrow_key|
      case arrow_key
        when KEY_W
          got_ud = true
          intended_forces[1] = this_direction
        when KEY_S
          got_ud = true
          intended_forces[1] = -this_direction
        when KEY_A
          got_lr = true
          intended_forces[0] = this_direction
        when KEY_D
          got_lr = true
          intended_forces[0] = -this_direction
      end
    end

    nx = @player_position[0] + (@player_velocity[0] * delta_time)
    ny = @player_position[2] + (@player_velocity[2] * delta_time)

    px = nx.round
    py = ny.round

    if px >= 0 && px < @maze_s && py >= 0 && py < @maze_s
      player_at_shape = (@maze[px.to_i][py.to_i] & PRIMARY)
    end

    case player_at_shape
      when 15
        allow_up = allow_down = allow_left = allow_right = true
      when 8
        allow_down = allow_left = allow_right = true
      when 7
        allow_up = allow_left = allow_right = true
      when 9
        allow_up = allow_down = allow_left = true
      when 6
        allow_up = allow_down = allow_right = true
      when 12
        allow_right = true
      when 11
        allow_left = true
      when 3
        allow_up = true
      when 5
        allow_down = true
      when 13
        allow_down = allow_up = true
        #TODO
        #includes left right crossing bits
      when 14
        allow_left = allow_right = true
      when 4
        allow_up = allow_left = true
      when 10
        allow_down = allow_left = true
      when 1
        allow_down = allow_right = true
      when 2
        allow_right = true
        allow_up = true
    end

    at_left_right_limit = ((nx - px))
    at_up_down_limit = ((ny - py))

    player_min = [at_left_right_limit + 0.05, at_up_down_limit + 0.05]
    player_max = [at_left_right_limit - 0.05, at_up_down_limit - 0.05]

    bounced = false
    correction = 0

    if ab = test_aabb(@top_left_min, @top_left_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if ab = test_aabb(@bottom_left_min, @bottom_left_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if ab = test_aabb(@bottom_right_min, @bottom_right_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if ab = test_aabb(@top_right_min, @top_right_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if !allow_left && ab = test_aabb(@no_left_min, @no_left_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if !allow_right && ab = test_aabb(@no_right_min, @no_right_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if !allow_up && ab = test_aabb(@no_up_min, @no_up_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if !allow_down && ab = test_aabb(@no_down_min, @no_down_max, player_min, player_max)
      bounced = ab[0]
      correction = ab[1]
    end

    if @maze_exit == [px, py]
      @at_exit_time += delta_time

      if @at_exit_time > 0.0
        return :level_up
      end
    elsif [-1, 0] == [px, py]
      @at_exit_time += delta_time

      if @at_exit_time > 0.0
        return :level_down
      end
    else
      @at_exit_time = 0.0
    end

    if !player_at_shape 
      @player_velocity[0] = -@player_velocity[0]
      @player_velocity[2] = -@player_velocity[2]
    else
      if bounced
        line = nil

        if bounced == :y
          line = [@lne_x1, @lne_y1, @lne_x2, @lne_y2]
        end

        if bounced == :x
          line = [@lin_x1, @lin_y1, @lin_x2, @lin_y2]
        end

        line_x1, line_y1, line_x2, line_y2 = line

        normalY = line_x2 - line_x1
        normalX = line_y1 - line_y2
        normalLength = Math.sqrt(normalX * normalX + normalY * normalY)
        normalX = normalX / normalLength
        normalY = normalY / normalLength
        rayTipX = @player_velocity[0]
        rayTipY = @player_velocity[2]
        rayX = rayTipX
        rayY = rayTipY 
        dotProduct = (rayX * normalX) + (rayY * normalY)
        dotNormalX = dotProduct * normalX
        dotNormalY = dotProduct * normalY
        reflectedRayTipX = rayTipX - (dotNormalX * 2)
        reflectedRayTipY = rayTipY - (dotNormalY * 2)
        @player_velocity[0] = (reflectedRayTipX * rfx)
        @player_velocity[2] = (reflectedRayTipY * rfy)
      else
        @player_position[0] = nx
        @player_position[2] = ny
      end
    end

    @time_since_last_hop += delta_time

    avx = intended_forces[0]
    avy = intended_forces[1]

    if !got_lr
      avx += (@player_velocity[0] * -1.0) * friction
    end

    if !got_ud
      avy += (@player_velocity[2] * -1.0) * friction
    end

    @player_velocity[0] += avx
    @player_velocity[2] += avy

    if @player_velocity[2] > max_v
      @player_velocity[2] = max_v
    end

    if @player_velocity[0] > max_v
      @player_velocity[0] = max_v
    end

    if @player_velocity[0] < -max_v
      @player_velocity[0] = -max_v
    end

    if @player_velocity[2] < -max_v
      @player_velocity[2] = -max_v
    end

    if px != @cpx
      @cpx = px
    end

    if py != @cpy
      @cpy = py
    end

    @px = px
    @py = py

    @players.each { |key, rpv|
      player_position, player_velocity = *rpv

      player_velocity[0] += (player_velocity[0] * -1.0) * friction
      player_velocity[2] += (player_velocity[2] * -1.0) * friction

      player_position[0] += (player_velocity[0] * delta_time)
      player_position[2] += (player_velocity[2] * delta_time)
    }

    if @time_since_last_hop > hop_timeout
      @time_since_last_hop = 0
      gl.emit({"position" => {$HEX => [@maze_level, @player_position, @player_velocity]}})
    end 

    :keep_running
  end

  def draw_threed(gl)
    return unless @maze && @px && @py

    ((@px-@maze_draw_distance)..(@px+@maze_draw_distance)).each do |x|
      ((@py-@maze_draw_distance)..(@py+@maze_draw_distance)).each do |y|
        if x>=0 && x<@maze_s && y>=0 && y<@maze_s
          cell = @maze[x][y]
          unless cell == 0
            primary = (cell & PRIMARY)
            if shape = @shapes[primary]
              shape.deltap(x, 0, y)
              shape.draw(false)
            end
          end
        end
      end
    end

    @cube.deltar(0.0, 1.0, 0.0, (Math.atan2(@player_velocity[0], @player_velocity[2]) * (180.0/3.14)) + 0.0)
    @cube.deltap(*@player_position)
    @cube.draw(false)
    
    @players.each { |key, rpv|
      player_position, player_velocity = *rpv

      @cube.deltar(0.0, 1.0, 0.0, (Math.atan2(player_velocity[0], player_velocity[2]) * (180.0/3.14)) + 0.0)
      @cube.deltap(*player_position)
      @cube.draw(false)
    }
  end

  def draw_twod(gl)
    gl.label(@maze_level.to_s + " | " + @ticks.to_s + " | " + ("%04.1f" % (@player_velocity[0] || 0.0)) + " | " + ("%04.1f" % ((@last_delta_time || 0.0) * 1000.0)) + " | " + ("%04.1f" % (@last_global_time || 0.0)))
  end

  def track_other_players!(msg)
    player_updated = msg.keys
    player_updated.each { |player|
      maze_level, player_position, player_velocity = msg[player]

      if @maze_level == maze_level
        @players.merge!({player => [player_position, player_velocity]})
      end
    }
  end

  #TODO: abstract this
  def test_aabb(min_a, max_a, min_b, max_b)
    d1x = -min_b[0] - -max_a[0]
    d1y = -min_b[1] - -max_a[1]
    d2x = -min_a[0] - -max_b[0]
    d2y = -min_a[1] - -max_b[1]

    if (d1x > 0.0 || d1y > 0.0)
      return false
    elsif (d2x > 0.0 || d2y > 0.0)
      return false
    else
      a = (d2x - d1x).abs
      b = (d2y - d1y).abs
      if a > b
        if d2x < d1x
          b = 0.0
        else
          b = 0.0
        end

        return [:y, b]
      else
        if d2y < d1y
          a = 0.0
        else
          a = 0.0
        end

        return [:x, a]
      end
    end
  end
end

Wkndr.nonce {
  Wkndr.client_side { |gl|
    gl.open_default_view!

    chicken_file = "resources/chicken.glb"
    cube = Model.new(chicken_file, "", 0.125)

    shapes = {}

    16.times { |i|
      shape_file = "resources/shape-#{i}.glb"
      shapes[i] = Model.new(shape_file, "", 1.0)
    }

    GameEngine.start(gl, cube, shapes)
  }
}

Wkndr.server_side { |gl, server|
  server.wsb("/")
}

Wkndr.client_side { |gl|
  gl.event { |channel, msg|
    GameEngine.event(channel, msg)
  }

  gl.update { |global_time, delta_time|
    GameEngine.process_time(gl, global_time, delta_time)

    gl.drawmode {
      gl.threed {
        GameEngine.draw_threed(gl)
      }
      gl.twod {
        GameEngine.draw_twod(gl)
      }
    }
  }
}
